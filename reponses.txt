QUESTION 1

— (2, 0)(2, 5)(4, 4)(4, 7)(5, 7)(5, 0)
non car (2, 5)(4, 4) pas horizontal
— (2, 0)(2, 5)(4, 5)(4, 7)(5, 7)(5, 0)
oui
— (2, 0)(2, 5)(4, 5)(4, 7)(5, 7)(6, 7)(5, 0)
(6, 7)(5, 0) pas vertical
— (2, 0)(2, 5)(4, 5)(4, 8)(4, 7)(5, 7)(5, 0)
(4, 8)(4, 7) fait une ligne (paratonnerre ? =D)


QUESTION 2

le premier y = 0, puis y change, puis x, puis y, ... puis y = 0 pour le dernier

QUESTION 3

(1, 1)(5, 13)(9, 20)(12, 27)(16, 3)(19, 0)(22, 3)(25, 0) =>

(1, 0)(1, 1)(5, 1)(5, 13)(9, 13)(9, 20)(12, 20)(12, 27)(16, 27)(16, 3)(19, 3)(19, 0)(22, 0)(22, 3)(25, 3)(25, 0)

QUESTION 4

FAUX
pour i = 0 à n
  pour j = 0 à hi
    t[gi][j] = true
  pour j = gi à di
    t[j][hi] = true
  pour j = hi à 0
    t[di][j] = true

i,j = 0

tant que (i < t.size)
  si (t[i][j+1] == true)
      on écrit le sommet
      tant que (t[i][j] == t[i][j+1])
        j++
      on écrit le sommet
  sinon si (t[i][j-1] == true)
      on écrit le sommet
      tant que (t[i][j] == t[i][j-1])
        j--
      on écrit le sommet
  i++


QUESTION 5

//on avance sur l'axe des abscisses jusqu'au premier point supérieur à  g
tant que (point_suivant existe && point_suivant.x < g)
    avancer le point suivant

//on insère 2 point représentant la ligne verticale gauche
si (point_suivant n'existe pas)
    insérer (g, 0) et se placer après
    insérer (g, h) et se placer après
sinon si (point_suivant.y < h)
    insérer (g, point_suivant.y) et se placer après
    insérer (g, h) et se placer après
sinon
    tant que (point_suivant.y >= h && point_suivant existe)
    avancer le point_suivant

//de g à d
//on efface les lignes de toit dont la hauteur est inférieure à h
//si on rencontre une ligne de toit plus haute, on inscrit les points correspondant à l'intersection de l'immeuble que l'on veut dessiner et de celui que l'on vient de rencontrer et on n'efface rien
tant que (point_suivant existe && point_suivant.x <= d)
    si (point_suivant.y > h)
        insérer (point_suivant.x, h) et se placer après
	tant que (point_suivant existe && point_suivant.x <= d && point_suivant.y > h)
	     avancer le point suivant
	insérer (point_suivant.x, h) et se placer après
    sinon
	retirer le point suivant de la liste (et récupérer celui d'après)

si (point_suivant n'existe pas)
    insérer (d, h) et se placer après
    insérer (d, 0)
sinon si (point_suivant.y < h)
    insérer (d, h) et se placer après
    insérer (d, point_suivant.y)
